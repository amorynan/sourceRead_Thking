#### http 的一次完整请求过程

从我们开始输入域名后，点击enter，整个网络发生了什么？

* #### **整体流程**

输入域名后 --&gt; 进行域名解析 -- &gt; 发起TCP的三次握手，进行可达性的连接确认 --&gt; 发起http的请求 --&gt; 服务器response http请求, 浏览器get html代码 ——&gt; 浏览器解析html代码，请求js， css等资源 --&gt; 浏览器对页面进行渲染

* _**域名解析**_ -- DNS 应用层服务；将域名转成IP，也就是找到人家实际的门牌号，DNS 解析的地方，要么是本地缓存（浏览器/系统/host），要么去本地配置的DNS服务器发起域名请求服务（一般就是运营商）

![](/assets/DNS.png)

* _**TCP 三次握手建立连接 -- 以及为什么要三次握手**_

在上面的域名解析成功的前提下，也就是浏览器客户端成功拿到对方的IP 后，现在要做的就是进行通讯的确认，也就是需要看对方端口和自己端口上传输的数据的可靠性

三次握手的图，随便找一张图

![](/assets/wKioL1LSW6rjI1nhAAE63Uv8ZRY731.jpg)

以上面图为例子，服务器的某端口一直处于监听的状态，从客户端的某个可行端口开始，经过TCP/IP协议栈的层层封装，和层层剥开传到sever端口，从Client的第一个包（主要信息SYN=1， ACK=0，seq = x)；其实包中不止这些信息，TCP的首段就包括20个字节，分别是源端口和目的端口，还有序号(seq)，确认号(ack), SYN, FIN, 等等，回归第一个包
想要确认sever是否在线，此时以SYN=1,ACK=0来说明这是一个连接请求的包，ack确认号无效，seq = x代表我发出的是x序列
sever 端口接收到之后，从监听状态变成了receive状态后，SYN = 1, ACK = 1, 代表我可以接受到你的连接请求，并且我发出的序列号seq = y， ack = x+1,我接受到你发给我的x序列了，我想要x+1序列，我需要你是否能接收到我的请求？
client端口接收到sever请求后，得到了它的序列号，所以想要更多的信息ack = y+1， 发出sever想要的序列seq=x+1,ACK = 1, 保证序列号有效
至此双方开始就达成协议建立好连接后开始可以传输数据交流了
那么为什么要三次连接呢？
其实关注整个过程，三次连接时能够保证双方达成通信的最低次数，同时也是验证双方都遵守TCP协议，可以进行连接，所以三次是能够保证可靠性数据传输和最高效率的次数，四次或者更高只是多次的确认

