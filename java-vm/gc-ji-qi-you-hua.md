### java VM -- 一个对内存进行管理的虚拟机，所以对内存方面其是下了很大的功夫的，今天主要来看一下

GC相关基础知识，包括但不限于：  
a\) GC工作原理。  
b\) 理解新生代、老年代、晋升等术语含义。  
c\) 可以看懂GC日志。

GC优化不能解决一切性能问题，它是最后的调优手段



JVM 的内存结构（基于“分代回收”机制） -- 将内存划分为不同的物理区 ： 新生代， 老年代， 永久代

* ### **首先GC工作原理 -- 分代回收（GC堆中托管的的是oop指针）**

#### 简单总结就是对于不同生命周期的对象，采用不同的垃圾回收机制，来提高效率

![](/assets/JVMpart.png)

#####  

1. 在新生代的回收叫做minor GC，在这里面有大量的对象被创建，也是GC最频繁的地方，很多的对象的生命周期很短，只有少量的对象存活，所以这里采用copy 算法，只需少量的copy就可以完成回收（在eden ， s0， s1均是）

如果eden区满员，将还存活的对象copy到s0或者s1，同时这些对象的生命值+1，当sx再次满员的时候，还存活的对象但不满足晋升年纪的就copy到sx\_other，若满足，就可以copy到老年代中，此晋升年纪是有一个值来确定，可以人工输入。

_**显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。**_

2. 老年代的对象就是存活率很大的对象，不容易GC，叫做\(major GC\), 所以采用标记-清理算法。

3. 还有一个full GC 对于就是整堆清理

4. 永久代，其实被分到了堆外内存，里面存放着klass元数据，所以不再GC范围

对于不同的垃圾算法，会有不同的垃圾回收器

* ### 简谈优化：

#### 若是minor 和 major GC频繁 -- 扩容

minor gc ，eden区生成大量的对象，复制s区，扩容，好处，减少GC次数，可能坏处，单次GC时间长，但是同时可能对象已经消失了，所以minor时间更多取决于GC后存活对象的数量，二本是eden区的大小



