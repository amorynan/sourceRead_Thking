### java VM -- 一个对内存进行管理的虚拟机，所以对内存方面其是下了很大的功夫的，今天主要来看一下

GC相关基础知识，包括但不限于：  
a\) GC工作原理。  
b\) 理解新生代、老年代、晋升等术语含义。  
c\) 可以看懂GC日志。

GC优化不能解决一切性能问题，它是最后的调优手段

JVM 的内存结构（基于“分代回收”机制） -- 将内存划分为不同的物理区 ： 新生代， 老年代， 永久代

* ### **首先GC工作原理 -- 分代回收（GC堆中托管的的是oop指针，正如c中的指针使用，给他分配空间，自然要手动释放空间，只不过这里GC可以帮助我们释放，就是清理）**

#### 简单总结就是对于不同生命周期的对象，采用不同的垃圾回收机制，来提高效率

![](/assets/JVMpart.png)

##### 

1. 在新生代的回收叫做minor GC，在这里面有大量的对象被创建，也是GC最频繁的地方，很多的对象的生命周期很短，只有少量的对象存活，所以这里采用copy 算法，只需少量的copy就可以完成回收（在eden ， s0， s1均是）

如果eden区满员，将还存活的对象copy到s0或者s1，同时这些对象的生命值+1，当sx再次满员的时候，还存活的对象但不满足晋升年纪的就copy到sx\_other，若满足，就可以copy到老年代中，此晋升年纪是有一个值来确定，可以人工输入。

_**显然，“晋升年龄阈值”的大小直接影响着对象在新生代中的停留时间，在Serial和ParNew GC两种回收器中，“晋升年龄阈值”通过参数MaxTenuringThreshold设定，默认值为15。**_

1. 老年代的对象就是存活率很大的对象，不容易GC，叫做\(major GC\), 所以采用标记-清理算法。

2. 还有一个full GC 对于就是整堆清理

3. 永久代，其实被分到了堆外内存，里面存放着klass元数据，所以不再GC范围

对于不同的垃圾算法，会有不同的垃圾回收器

![](/assets/myGC.png)

* ### 简谈优化：

#### 若是minor 和 major GC频繁 -- 扩容

minor gc ，eden区生成大量的对象，复制s区，扩容，好处，减少GC次数，可能坏处，单次GC时间长，但是同时可能对象已经消失了，所以minor时间更多取决于GC后存活对象的数量，二本是eden区的大小

_**总结：得根据应用程序生命周期的分布的情况而言，如果是朝生夕死的比较多，那么就扩容新生代的比较好，如果是相对多的持久对象，那扩容老年代比较好**_

#### STW -- 高峰期的GC  CMS -- 手动增加一次minor GC

CMS 标记-清理算法，主要就是进行的可达性的分析，从init-mark（GC root可达性）-&gt;concurrent-remark\(由init-remark的存活对象为root开始并行可达性，会造成可达性的可达性的不准确\)-&gt; remark（STW,可达性，扫描整个堆，只不过需要注意的是是以新生代对象为root进行的可达性的存活判断）-&gt;清理

所以在进行CMS 的remark时候进行的全堆扫描的消耗会在新生代上面有大量的消耗，而又针对新生代的找生夕灭的特点，完全可以在remark之前先进行一次minor GC，这样可以完全做到扫新生代的时间优化，当然在CMS中有采用可中断的并发预清理，这里还是锁的看并发清理对象的是否依旧存活，但是主要是来等待着minor gc的到来，只不过这个阶段可被中断，为了防止无限等待，又有一个中断的最大时间值（default 5s），要是超过时间，就直接进入remark，一般时间会超过5s的话，就强制添加一次minor gc

总结：

_**由于跨代引用的存在，CMS在Remark阶段必须扫描整个堆，同时为了避免扫描时新生代有很多对象，增加了可中断的预清理阶段用来等待Minor GC的发生。只是该阶段有时间限制，如果超时等不到Minor GC，Remark时新生代仍然有很多对象，我们的调优策略是，通过参数强制Remark前进行一次Minor GC，从而降低Remark阶段的时间。**_



