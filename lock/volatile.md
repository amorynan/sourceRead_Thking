Volatile : \(1\) 保证可见性，对所有线程可见； （2） 保证有序性，可以有效的防止JVM CPU 调优时候的重排 （３）但是不保证原子性，所以不一定是安全的

为什么这么说呢？volatile主要保证的是一种有序的过程，比如一个线程改变值的时候，另外一个线程读值，那么另外一个线程读值的顺序就一定在写值之后才会进行，所以可以一定程度上的满足线程安全，但是又不是安全的原因，是如果所有的线程都是写值的操作，那么这个时候不存在什么有序化的过程，而在对值进行一系列的操作的时候，并不是原子性的，而是read - load - assign等等，这样原子性操作的组合，那么在某一个线程进行着一系列的同时，另外一个线程早就已经use了很多次

所以在多线程都要修改变量的值的时候就会存在问题，要么我们保证单一线程修改变量

volatile 的使用场景 ： 不需要原子性的操作，但是需要可见性 -- 比如线程的结束标记



